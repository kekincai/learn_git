progit.pdf 的批注摘要。


关于版本控制

高亮 [15]: RCS 的工作原理是在硬盘上保存补 丁集（补丁是指文件修订前后的变化）；通过应用所有的补丁，可以重新计算出各个版本的文件内容。


Git 简史

高亮 [18]: 他们对新的系统制订了若干目标：

• 速度

• 简单的设计

• 对非线性开发模式的强力支持（允许成千上万个并行开发的分支）

• 完全分布式

• 有能力高效管理类似 Linux 内核一样的超大规模项目（速度和数据量）


Git 是什么？

高亮 [18]: Git 是什么？

高亮 [18]: 直接记录快照，而非差异比较

高亮 [20]: Git 保证完整性

高亮 [20]: Git 中所有的数据在存储前都计算校验和，然后以校验和来引用。 这意味着不可能在 Git 不知情时更改任何文件 内容或目录内容。…

高亮 [20]: 实际上，Git 数据库中保存的信息都是以文件内 容的哈希值来索引，而不是文件名。

高亮 [20]: Git 一般只添加数据

高亮 [20]: Git 有三种状态，你的文件可能 处于其中之一： 已提交（committed）、已修改（modified） 和 已暂存（staged）。

• 已修改表示修改了文件，但还没保存到数据库中。

• 已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。

• 已提交表示数据已经安全地保存在本地数据库中。

这会让我们的 Git 项目拥有三个阶段：工作区、暂存区以及 Git 目录。

高亮 [21]: 工作区是对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上 供你使用或修改。

暂存区是一个文件，保存了下次将要提交的文件列表信息，一般在 Git 仓库目录中。 按照 Git 的术语叫做“索 引”，不过一般说法还是叫“暂存区”。

高亮 [21]: Git 仓库目录是 Git 用来保存项目的元数据和对象数据库的地方。 这是 Git 中最重要的部分，从其它计算机克隆 仓库时，复制的就是这里的数据。

高亮 [21]: 基本的 Git 工作流程如下：

1. 在工作区中修改文件。

2. 将你想要下次提交的更改选择性地暂存，这样只会将更改的部分添加到暂存区。

3. 提交更新，找到暂存区的文件，将快照永久性存储到 Git 目录。


获取 Git 仓库

高亮 [29]: 通常有两种获取 Git 项目仓库的方式：

1. 将尚未进行版本控制的本地目录转换为 Git 仓库；

2. 从其它服务器 克隆 一个已存在的 Git 仓库。

高亮 [30]: 如果你想在克隆远程仓库的时候，自定义本地仓库的名字，你可以通过额外的参数指定新的目录名：

$ git clone https://github.com/libgit2/libgit2 mylibgit

高亮 [30]: 这会执行与上一条命令相同的操作，但目标目录名变为了 mylibgit。


记录每次更新到仓库

高亮 [30]: 请记住，你工作目录下的每一个文件都不外乎这两种状态：已跟踪 或 未跟踪。 已跟踪的文件是指那些被纳入了 版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后， 它们的状态可能是未修改，已修改或已

30

高亮 [31]: 放入暂存区。简而言之，已跟踪的文件就是 Git 已经知道的文件。

高亮 [33]: 要暂存这次更新，需要运行 git add 命令。 这是个多功能命令：可以用它开 始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。…

高亮 [42]: 移动文件

不像其它的 VCS 系统，Git 并不显式跟踪文件移动操作。 如果在 Git 中重命名了某个文件，仓库中存储的元数 据并不会体现出这是一次改名操作。 不过 Git 非常聪明，它会推断出究竟发生了什么，至于具体是如何做到的， 我们稍后再谈。


远程仓库的使用

高亮 [55]: $ git fetch <remote>

这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支 的引用，可以随时合并或查看。

高亮 [55]: 必须注意 git fetch 命令只会 将数据下载到你的本地仓库——它并不会自动合并或修改你当前的工作。…

高亮 [55]: 当准备好时你必须手动将其合并入你的 工作。

高亮 [55]: 如果你的当前分支设置了跟踪远程分支（阅读下一节和 Git 分支 了解更多信息）， 那么可以用 git pull 命令 来自动抓取后合并该远程分支到当前分支。…

高亮 [57]: 一旦你使用这种方式删除了一个远程仓库，那么所有和这个远程仓库相关的远程跟踪分支以及配置信息也会一起 被删除。


Git 分支

高亮 [65]: 与许多其它版本控制系统不同，Git 鼓励在工作流 程中频繁地使用分支与合并，哪怕一天之内进行许多次。…


分支简介

高亮 [65]: 或许你还记得 起步 的内容， Git 保存的不是文件的变化或者差异，而是一系列不同时刻的 快照 。

高亮 [66]: Git 的分支，其实本质上仅仅是指向提交对象的可变指针。…

高亮 [66]: Git 的 master 分支并不是一个特殊分支。 它就跟其它分支完全没有区别。 之所以几乎每一 个仓库都有 master 分支，是因为 git init 命令默认创建它，并且大多数人都懒得去改动 它。

高亮 [67]: Git 是怎么创建新分支的呢？ 很简单，它只是为你创建了一个可以移动的新的指针。…

高亮 [71]: 由于 Git 的分支实质上仅是包含所指对象校验和（长度为 40 的 SHA-1 值字符串）的文件，所以它的创建和销毁 都异常高效。…


分支的新建与合并

高亮 [72]: 分支的新建与合并

让我们来看一个简单的分支新建与分支合并的例子，实际工作中你可能会用到类似的工作流。 你将经历如下步 骤：

1. 开发某个网站。

2. 为实现某个新的用户需求，创建一个分支。

3. 在这个分支上开展工作。

正在此时，你突然接到一个电话说有个很严重的问题需要紧急修补。 你将按照如下方式来处理：

1. 切换到你的线上分支（production branch）。

2. 为这个紧急任务新建一个分支，并在其中修复它。

3. 在测试通过之后，切换回线上分支，然后合并这个修补分支，最后将改动推送到线上分支。

4. 切换回你最初工作的分支上，继续工作。


变基

高亮 [94]: 其实，还有一种方法：你可以提取在 C4 中引入的补丁和修改，然后在 C3 的基础上应用一次。 在 Git 中，这种 操作就叫做 变基（rebase）。…

高亮 [96]: 请注意，无论是通过变基，还是通过三方合并，整合的最终结果所指向的快照始终是一样的，只不过提交历史不 同罢了。 变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。

高亮 [98]: 变基的风险

呃，奇妙的变基也并非完美无缺，要用它得遵守一条准则：

如果提交存在于你的仓库之外，而别人可能基于这些提交进行开发，那么不要执行变基。

高亮 [98]: 如果你遵循这条金科玉律，就不会出差错。 否则，人民群众会仇恨你，你的朋友和家人也会嘲笑你，唾弃你。

高亮 [103]: 变基 vs. 合并

高亮 [103]: 总的原则是，只对尚未推送或分享给别人的本地修改执行变基操作清理历史， 从不对已推送至别处的提交执行 变基操作，这样，你才能享受到两种方式带来的便利。